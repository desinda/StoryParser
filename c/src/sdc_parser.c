/**
 * File generated by Claude AI - 2025-10-09
 */

#include "sdc_parser.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// ============================================================================
// INTERNAL STRUCTURES (not exposed in header)
// ============================================================================

typedef enum {
    // Literals
    TOKEN_IDENTIFIER,
    TOKEN_STRING,
    TOKEN_NUMBER,
    TOKEN_FLOAT,
    TOKEN_CODE_BLOCK,
    TOKEN_TRUE,
    TOKEN_FALSE,
    
    // Keywords
    TOKEN_STATES,
    TOKEN_GLOBAL_VARS,
    TOKEN_DEFAULT,
    TOKEN_TITLE,
    TOKEN_TAGS,
    TOKEN_CHAPTER,
    TOKEN_GROUP,
    TOKEN_NODE,
    TOKEN_NAME,
    TOKEN_CONTENT,
    TOKEN_TYPE,
    TOKEN_COLOR,
    TOKEN_KEYS,
    TOKEN_TIMELINE,
    TOKEN_ACTION,
    TOKEN_DIALOGUE,
    TOKEN_CHOICE,
    TOKEN_CHOICES,
    TOKEN_TEXT,
    TOKEN_GOTO,
    TOKEN_EXIT,
    TOKEN_ENTER,
    TOKEN_NODES,
    TOKEN_START,
    TOKEN_END,
    TOKEN_POINTS,
    TOKEN_DATA,
    TOKEN_INCREMENT,
    TOKEN_VALUE,
    TOKEN_TOGGLE,
    TOKEN_CHARACTER,
    TOKEN_EVENT,
    TOKEN_LINKED_LISTS,
    TOKEN_AMOUNT,
    TOKEN_APPEND,
    TOKEN_BIOGRAPHY,
    TOKEN_CHARACTERS,
    TOKEN_DESCRIPTION,
    TOKEN_LINKED_LIST_DATA,
    TOKEN_PARENT_GROUP,
    TOKEN_REFERENCE,
    TOKEN_REPLACE,
    TOKEN_SCOPE,
    TOKEN_STRUCTURE,
    TOKEN_SET,
    TOKEN_VALUES,
    
    // Symbols
    TOKEN_LBRACE,
    TOKEN_RBRACE,
    TOKEN_LBRACKET,
    TOKEN_RBRACKET,
    TOKEN_COLON,
    TOKEN_COMMA,
    TOKEN_AT,
    TOKEN_LPAREN,
    TOKEN_RPAREN,
    
    // Special
    TOKEN_EOF,
    TOKEN_ERROR
} TokenType;

typedef struct {
    TokenType type;
    char* lexeme;
    int line;
    int column;
    
    union {
        long number;
        double float_number;
        char* string;
        bool bool_value;
    } value;
} Token;

typedef struct {
    const char* source;
    const char* start;
    const char* current;
    int line;
    int column;
    
    Token* tokens;
    int token_count;
    int token_capacity;
} Lexer;

typedef struct {
    Token* tokens;
    int token_count;
    int current;
    
    StoryData* story;
    char* error_message;
} Parser;

// Global error message storage
static char* last_error = NULL;

// ============================================================================
// LEXER IMPLEMENTATION
// ============================================================================

static Lexer* lexer_create(const char* source) {
    Lexer* lexer = (Lexer*)malloc(sizeof(Lexer));
    lexer->source = source;
    lexer->start = source;
    lexer->current = source;
    lexer->line = 1;
    lexer->column = 1;
    lexer->token_count = 0;
    lexer->token_capacity = 256;
    lexer->tokens = (Token*)malloc(sizeof(Token) * lexer->token_capacity);
    return lexer;
}

static void lexer_free(Lexer* lexer) {
    for (int i = 0; i < lexer->token_count; i++) {
        free(lexer->tokens[i].lexeme);
        if (lexer->tokens[i].type == TOKEN_STRING || 
            lexer->tokens[i].type == TOKEN_CODE_BLOCK) {
            free(lexer->tokens[i].value.string);
        }
    }
    free(lexer->tokens);
    free(lexer);
}

static inline bool is_at_end(Lexer* lexer) {
    return *lexer->current == '\0';
}

static inline char advance(Lexer* lexer) {
    char c = *lexer->current++;
    lexer->column++;
    return c;
}

static inline char peek(Lexer* lexer) {
    return *lexer->current;
}

static inline char peek_next(Lexer* lexer) {
    if (is_at_end(lexer)) return '\0';
    return lexer->current[1];
}

static void add_token(Lexer* lexer, TokenType type) {
    if (lexer->token_count >= lexer->token_capacity) {
        lexer->token_capacity *= 2;
        lexer->tokens = (Token*)realloc(lexer->tokens, 
                                       sizeof(Token) * lexer->token_capacity);
    }
    
    Token token;
    token.type = type;
    token.line = lexer->line;
    token.column = lexer->column - (int)(lexer->current - lexer->start);
    
    int length = (int)(lexer->current - lexer->start);
    token.lexeme = (char*)malloc(length + 1);
    memcpy(token.lexeme, lexer->start, length);
    token.lexeme[length] = '\0';
    
    lexer->tokens[lexer->token_count++] = token;
}

static void skip_whitespace(Lexer* lexer) {
    while (true) {
        char c = peek(lexer);
        switch (c) {
            case ' ':
            case '\r':
            case '\t':
                advance(lexer);
                break;
            case '\n':
                lexer->line++;
                lexer->column = 0;
                advance(lexer);
                break;
            case '#':
                while (peek(lexer) != '\n' && !is_at_end(lexer)) {
                    advance(lexer);
                }
                break;
            default:
                return;
        }
    }
}

static bool is_digit(char c) {
    return c >= '0' && c <= '9';
}

static bool is_alpha(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}

static void scan_string(Lexer* lexer) {
    advance(lexer);  // Consume opening quote
    const char* string_start = lexer->current;
    
    while (peek(lexer) != '"' && !is_at_end(lexer)) {
        if (peek(lexer) == '\n') {
            lexer->line++;
            lexer->column = 0;
        }
        advance(lexer);
    }
    
    if (is_at_end(lexer)) {
        add_token(lexer, TOKEN_ERROR);
        return;
    }
    
    int length = (int)(lexer->current - string_start);
    advance(lexer);  // Consume closing quote
    
    Token token;
    token.type = TOKEN_STRING;
    token.line = lexer->line;
    token.column = lexer->column - (int)(lexer->current - lexer->start);
    
    int lexeme_length = (int)(lexer->current - lexer->start);
    token.lexeme = (char*)malloc(lexeme_length + 1);
    memcpy(token.lexeme, lexer->start, lexeme_length);
    token.lexeme[lexeme_length] = '\0';
    
    token.value.string = (char*)malloc(length + 1);
    memcpy(token.value.string, string_start, length);
    token.value.string[length] = '\0';
    
    if (lexer->token_count >= lexer->token_capacity) {
        lexer->token_capacity *= 2;
        lexer->tokens = (Token*)realloc(lexer->tokens, 
                                       sizeof(Token) * lexer->token_capacity);
    }
    
    lexer->tokens[lexer->token_count++] = token;
}

static void scan_number(Lexer* lexer) {
    bool is_float = false;
    bool is_negative = false;
    
    // Handle negative sign
    if (peek(lexer) == '-') {
        is_negative = true;
        advance(lexer);
    }
    
    while (is_digit(peek(lexer))) {
        advance(lexer);
    }
    
    // Check for decimal point
    if (peek(lexer) == '.' && is_digit(peek_next(lexer))) {
        is_float = true;
        advance(lexer);  // Consume '.'
        
        while (is_digit(peek(lexer))) {
            advance(lexer);
        }
    }
    
    Token token;
    token.type = is_float ? TOKEN_FLOAT : TOKEN_NUMBER;
    token.line = lexer->line;
    token.column = lexer->column - (int)(lexer->current - lexer->start);
    
    int length = (int)(lexer->current - lexer->start);
    token.lexeme = (char*)malloc(length + 1);
    memcpy(token.lexeme, lexer->start, length);
    token.lexeme[length] = '\0';
    
    if (is_float) {
        token.value.float_number = strtod(token.lexeme, NULL);
    } else {
        token.value.number = strtol(token.lexeme, NULL, 10);
    }
    
    if (lexer->token_count >= lexer->token_capacity) {
        lexer->token_capacity *= 2;
        lexer->tokens = (Token*)realloc(lexer->tokens, 
                                       sizeof(Token) * lexer->token_capacity);
    }
    
    lexer->tokens[lexer->token_count++] = token;
}

static TokenType check_keyword(const char* start, int length, 
                               const char* rest, TokenType type) {
    if (memcmp(start, rest, length) == 0) {
        return type;
    }
    return TOKEN_IDENTIFIER;
}

static TokenType identifier_type(Lexer* lexer) {
    int length = (int)(lexer->current - lexer->start);
    const char* start = lexer->start;
    
    switch (start[0]) {
        case 'a':
            if (length == 6) return check_keyword(start, 6, "action", TOKEN_ACTION);
            if (length == 6) return check_keyword(start, 6, "amount", TOKEN_AMOUNT);
            if (length == 6) return check_keyword(start, 6, "append", TOKEN_APPEND);
            break;
        case 'b':
            if (length == 9) return check_keyword(start, 9, "biography", TOKEN_BIOGRAPHY);
            break;
        case 'c':
            if (length == 7) {
                if (memcmp(start, "chapter", 7) == 0) return TOKEN_CHAPTER;
                if (memcmp(start, "content", 7) == 0) return TOKEN_CONTENT;
                if (memcmp(start, "choices", 7) == 0) return TOKEN_CHOICES;
            }
            if (length == 6) return check_keyword(start, 6, "choice", TOKEN_CHOICE);
            if (length == 5) return check_keyword(start, 5, "color", TOKEN_COLOR);
            if (length == 9) return check_keyword(start, 9, "character", TOKEN_CHARACTER);
            if (length == 10) return check_keyword(start, 10, "characters", TOKEN_CHARACTERS);
            break;
        case 'd':
            if (length == 8) return check_keyword(start, 8, "dialogue", TOKEN_DIALOGUE);
            if (length == 7) return check_keyword(start, 7, "default", TOKEN_DEFAULT);
            if (length == 4) return check_keyword(start, 4, "data", TOKEN_DATA);
            if (length == 11) return check_keyword(start, 11, "description", TOKEN_DESCRIPTION);
            break;
        case 'e':
            if (length == 5) {
                if (memcmp(start, "enter", 5) == 0) return TOKEN_ENTER;
                if (memcmp(start, "event", 5) == 0) return TOKEN_EVENT;
            }
            if (length == 4) return check_keyword(start, 4, "exit", TOKEN_EXIT);
            if (length == 3) return check_keyword(start, 3, "end", TOKEN_END);
            break;
        case 'f':
            if (length == 5) return check_keyword(start, 5, "false", TOKEN_FALSE);
            break;
        case 'g':
            if (length == 11) return check_keyword(start, 11, "global-vars", TOKEN_GLOBAL_VARS);
            if (length == 5) return check_keyword(start, 5, "group", TOKEN_GROUP);
            if (length == 4) return check_keyword(start, 4, "goto", TOKEN_GOTO);
            break;
        case 'i':
            if (length == 9) return check_keyword(start, 9, "increment", TOKEN_INCREMENT);
            break;
        case 'k':
            if (length == 4) return check_keyword(start, 4, "keys", TOKEN_KEYS);
            break;
        case 'l':
            if (length == 12) return check_keyword(start, 12, "linked-lists", TOKEN_LINKED_LISTS);
            if (length == 16) return check_keyword(start, 16, "linked-list-data", TOKEN_LINKED_LIST_DATA);
            break;
        case 'n':
            if (length == 4) {
                if (memcmp(start, "name", 4) == 0) return TOKEN_NAME;
                if (memcmp(start, "node", 4) == 0) return TOKEN_NODE;
            }
            if (length == 5) return check_keyword(start, 5, "nodes", TOKEN_NODES);
            break;
        case 'p':
            if (length == 6) return check_keyword(start, 6, "points", TOKEN_POINTS);
            if (length == 12) return check_keyword(start, 11, "parent-group", TOKEN_PARENT_GROUP);
            break;
        case 'r':
            if (length == 9) return check_keyword(start, 9, "reference", TOKEN_REFERENCE);
            if (length == 7) return check_keyword(start, 7, "replace", TOKEN_REPLACE);
            break;
        case 's':
            if (length == 6) return check_keyword(start, 6, "states", TOKEN_STATES);
            if (length == 5) {
                if (memcmp(start, "start", 5) == 0) return TOKEN_START;
                if (memcmp(start, "scope", 5) == 0) return TOKEN_SCOPE;
            }
            if (length == 9) return check_keyword(start, 9, "structure", TOKEN_STRUCTURE);
            if (length == 3) return check_keyword(start, 3, "set", TOKEN_SET);
            break;
        case 't':
            if (length == 4) {
                if (memcmp(start, "tags", 4) == 0) return TOKEN_TAGS;
                if (memcmp(start, "type", 4) == 0) return TOKEN_TYPE;
                if (memcmp(start, "text", 4) == 0) return TOKEN_TEXT;
                if (memcmp(start, "true", 4) == 0) return TOKEN_TRUE;
            }
            if (length == 5) {
                if (memcmp(start, "title", 5) == 0) return TOKEN_TITLE;
            }
            if (length == 6) return check_keyword(start, 6, "toggle", TOKEN_TOGGLE);
            if (length == 8) return check_keyword(start, 8, "timeline", TOKEN_TIMELINE);
            break;
        case 'v':
            if (length == 5) return check_keyword(start, 5, "value", TOKEN_VALUE);
            if (length == 6) return check_keyword(start, 6, "values", TOKEN_VALUES);
            break;
    }
    
    return TOKEN_IDENTIFIER;
}

static void scan_identifier(Lexer* lexer) {
    while (is_alpha(peek(lexer)) || is_digit(peek(lexer)) || peek(lexer) == '-') {
        advance(lexer);
    }
    
    TokenType type = identifier_type(lexer);
    
    // For TRUE and FALSE, set the bool value
    if (type == TOKEN_TRUE || type == TOKEN_FALSE) {
        if (lexer->token_count >= lexer->token_capacity) {
            lexer->token_capacity *= 2;
            lexer->tokens = (Token*)realloc(lexer->tokens, 
                                           sizeof(Token) * lexer->token_capacity);
        }
        
        Token token;
        token.type = type;
        token.line = lexer->line;
        token.column = lexer->column - (int)(lexer->current - lexer->start);
        
        int length = (int)(lexer->current - lexer->start);
        token.lexeme = (char*)malloc(length + 1);
        memcpy(token.lexeme, lexer->start, length);
        token.lexeme[length] = '\0';
        
        token.value.bool_value = (type == TOKEN_TRUE);
        
        lexer->tokens[lexer->token_count++] = token;
    } else {
        add_token(lexer, type);
    }
}

static void scan_code_block(Lexer* lexer) {
    advance(lexer);  // <
    advance(lexer);  // !
    
    const char* code_start = lexer->current;
    
    while (!is_at_end(lexer)) {
        if (peek(lexer) == '!' && peek_next(lexer) == '>') {
            break;
        }
        if (peek(lexer) == '\n') {
            lexer->line++;
            lexer->column = 0;
        }
        advance(lexer);
    }
    
    if (is_at_end(lexer)) {
        add_token(lexer, TOKEN_ERROR);
        return;
    }
    
    int length = (int)(lexer->current - code_start);
    
    advance(lexer);  // !
    advance(lexer);  // >
    
    Token token;
    token.type = TOKEN_CODE_BLOCK;
    token.line = lexer->line;
    token.column = lexer->column - (int)(lexer->current - lexer->start);
    
    int lexeme_length = (int)(lexer->current - lexer->start);
    token.lexeme = (char*)malloc(lexeme_length + 1);
    memcpy(token.lexeme, lexer->start, lexeme_length);
    token.lexeme[lexeme_length] = '\0';
    
    token.value.string = (char*)malloc(length + 1);
    memcpy(token.value.string, code_start, length);
    token.value.string[length] = '\0';
    
    if (lexer->token_count >= lexer->token_capacity) {
        lexer->token_capacity *= 2;
        lexer->tokens = (Token*)realloc(lexer->tokens, 
                                       sizeof(Token) * lexer->token_capacity);
    }
    
    lexer->tokens[lexer->token_count++] = token;
}

static void lexer_scan_tokens(Lexer* lexer) {
    while (!is_at_end(lexer)) {
        lexer->start = lexer->current;
        skip_whitespace(lexer);
        
        if (is_at_end(lexer)) break;
        
        lexer->start = lexer->current;
        char c = advance(lexer);
        
        switch (c) {
            case '{': add_token(lexer, TOKEN_LBRACE); break;
            case '}': add_token(lexer, TOKEN_RBRACE); break;
            case '[': add_token(lexer, TOKEN_LBRACKET); break;
            case ']': add_token(lexer, TOKEN_RBRACKET); break;
            case ':': add_token(lexer, TOKEN_COLON); break;
            case ',': add_token(lexer, TOKEN_COMMA); break;
            case '@': add_token(lexer, TOKEN_AT); break;
            case '(': add_token(lexer, TOKEN_LPAREN); break;
            case ')': add_token(lexer, TOKEN_RPAREN); break;
            
            case '<':
                if (peek(lexer) == '!') {
                    lexer->current--;
                    lexer->column--;
                    scan_code_block(lexer);
                } else {
                    add_token(lexer, TOKEN_ERROR);
                }
                break;
            
            case '"':
                lexer->current--;
                lexer->column--;
                scan_string(lexer);
                break;
            
            case '-':
                if (is_digit(peek(lexer))) {
                    lexer->current--;
                    lexer->column--;
                    scan_number(lexer);
                } else {
                    lexer->current--;
                    lexer->column--;
                    scan_identifier(lexer);
                }
                break;
            
            default:
                if (is_digit(c)) {
                    lexer->current--;
                    lexer->column--;
                    scan_number(lexer);
                } else if (is_alpha(c)) {
                    lexer->current--;
                    lexer->column--;
                    scan_identifier(lexer);
                } else {
                    add_token(lexer, TOKEN_ERROR);
                }
                break;
        }
    }
    
    lexer->start = lexer->current;
    add_token(lexer, TOKEN_EOF);
}

// ============================================================================
// PARSER IMPLEMENTATION
// ============================================================================

static Parser* parser_create(Token* tokens, int token_count) {
    Parser* parser = (Parser*)malloc(sizeof(Parser));
    parser->tokens = tokens;
    parser->token_count = token_count;
    parser->current = 0;
    parser->error_message = NULL;
    
    parser->story = (StoryData*)malloc(sizeof(StoryData));
    parser->story->states = NULL;
    parser->story->state_count = 0;
    parser->story->global_vars = NULL;
    parser->story->global_var_count = 0;
    parser->story->tags = NULL;
    parser->story->tag_count = 0;
    parser->story->chapters = NULL;
    parser->story->chapter_count = 0;
    parser->story->groups = NULL;
    parser->story->group_count = 0;
    parser->story->nodes = NULL;
    parser->story->node_count = 0;
    
    return parser;
}

static void parser_free(Parser* parser) {
    if (parser->error_message) {
        free(parser->error_message);
    }
    free(parser);
}

static Token* peek_parser(Parser* parser) {
    return &parser->tokens[parser->current];
}

static Token* previous(Parser* parser) {
    return &parser->tokens[parser->current - 1];
}

static bool is_at_end_parser(Parser* parser) {
    return peek_parser(parser)->type == TOKEN_EOF;
}

static Token* advance_parser(Parser* parser) {
    if (!is_at_end_parser(parser)) parser->current++;
    return previous(parser);
}

static bool check(Parser* parser, TokenType type) {
    if (is_at_end_parser(parser)) return false;
    return peek_parser(parser)->type == type;
}

static bool match(Parser* parser, TokenType type) {
    if (check(parser, type)) {
        advance_parser(parser);
        return true;
    }
    return false;
}

static void set_error(Parser* parser, const char* message) {
    if (parser->error_message) return;  // Keep first error
    
    Token* token = peek_parser(parser);
    char buffer[512];
    snprintf(buffer, sizeof(buffer), "Error at line %d, column %d: %s (got '%s')",
             token->line, token->column, message, token->lexeme);
    
    parser->error_message = strdup(buffer);
    if (last_error) free(last_error);
    last_error = strdup(buffer);
}

static bool expect(Parser* parser, TokenType type, const char* message) {
    if (check(parser, type)) {
        advance_parser(parser);
        return true;
    }
    set_error(parser, message);
    return false;
}

// Forward declarations
static bool parse_states(Parser* parser);
static bool parse_global_vars(Parser* parser);
static bool parse_tags(Parser* parser);
static bool parse_tag_definition(Parser* parser, TagDefinition* tag);
static bool parse_chapter(Parser* parser, Chapter* chapter);
static bool parse_group(Parser* parser, Group* group);
static bool parse_node(Parser* parser, Node* node);

static bool parse_linked_lists(Parser* parser) {
    if (!expect(parser, TOKEN_LINKED_LISTS, "Expected 'linked-lists'")) return false;
    if (!expect(parser, TOKEN_LBRACKET, "Expected '[' after 'linked-lists'")) return false;
    
    // Count linked lists first
    int count = 0;
    int saved_pos = parser->current;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            count++;
            advance_parser(parser);
            if (check(parser, TOKEN_COLON)) {
                advance_parser(parser);
            }
            if (check(parser, TOKEN_LBRACE)) {
                int brace_count = 1;
                advance_parser(parser);
                while (brace_count > 0 && !is_at_end_parser(parser)) {
                    if (check(parser, TOKEN_LBRACE)) brace_count++;
                    if (check(parser, TOKEN_RBRACE)) brace_count--;
                    advance_parser(parser);
                }
            }
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    parser->current = saved_pos;
    
    // Allocate linked list array
    parser->story->linked_lists = (LinkedListDefinition*)calloc(count, sizeof(LinkedListDefinition));
    parser->story->linked_list_count = count;
    
    // Parse linked lists
    int list_index = 0;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            Token* name_token = advance_parser(parser);
            LinkedListDefinition* list = &parser->story->linked_lists[list_index++];
            list->name = strdup(name_token->value.string);
            list->scope = NULL;
            list->field_names = NULL;
            list->fields = NULL;
            list->field_count = 0;
            
            if (!expect(parser, TOKEN_COLON, "Expected ':' after linked-list name")) return false;
            if (!expect(parser, TOKEN_LBRACE, "Expected '{' after ':'")) return false;
            
            while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                if (match(parser, TOKEN_SCOPE)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'scope'")) return false;
                    Token* scope_token = advance_parser(parser);
                    list->scope = strdup(scope_token->value.string);
                } else if (match(parser, TOKEN_STRUCTURE)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'structure'")) return false;
                    if (!expect(parser, TOKEN_LBRACE, "Expected '{' after 'structure:'")) return false;
                    
                    // Count fields
                    int field_count = 0;
                    int saved_pos2 = parser->current;
                    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                        if (check(parser, TOKEN_IDENTIFIER)) {
                            field_count++;
                            advance_parser(parser);
                            if (check(parser, TOKEN_COLON)) {
                                advance_parser(parser);
                                if (check(parser, TOKEN_LBRACE)) {
                                    int brace_count = 1;
                                    advance_parser(parser);
                                    while (brace_count > 0 && !is_at_end_parser(parser)) {
                                        if (check(parser, TOKEN_LBRACE)) brace_count++;
                                        if (check(parser, TOKEN_RBRACE)) brace_count--;
                                        advance_parser(parser);
                                    }
                                }
                            }
                        } else {
                            advance_parser(parser);
                        }
                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                    }
                    parser->current = saved_pos2;
                    
                    list->field_count = field_count;
                    list->field_names = (char**)malloc(sizeof(char*) * field_count);
                    list->fields = (LinkedListField*)malloc(sizeof(LinkedListField) * field_count);
                    
                    // Parse fields
                    int field_index = 0;
                    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                        if (check(parser, TOKEN_IDENTIFIER)) {
                            Token* field_name = advance_parser(parser);
                            list->field_names[field_index] = strdup(field_name->lexeme);
                            
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after field name")) return false;
                            if (!expect(parser, TOKEN_LBRACE, "Expected '{' after field name")) return false;
                            
                            while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                                if (match(parser, TOKEN_TYPE)) {
                                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'type'")) return false;
                                    Token* type_token = advance_parser(parser);
                                    list->fields[field_index].type = strdup(type_token->value.string);
                                } else {
                                    advance_parser(parser);
                                }
                                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                            }
                            
                            if (!expect(parser, TOKEN_RBRACE, "Expected '}' after field definition")) return false;
                            field_index++;
                        } else {
                            advance_parser(parser);
                        }
                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                    }
                    
                    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after structure")) return false;
                } else {
                    advance_parser(parser);
                }
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            
            if (!expect(parser, TOKEN_RBRACE, "Expected '}' after linked-list definition")) return false;
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after linked-lists")) return false;
    return true;
}

static LinkedListData parse_linked_list_data_value(Parser* parser) {
    LinkedListData data;
    data.instances = NULL;
    data.count = 0;
    data.is_array = false;
    
    if (check(parser, TOKEN_LBRACKET)) {
        // Array of instances
        advance_parser(parser);
        data.is_array = true;
        
        // Count instances
        int instance_count = 0;
        int saved_pos = parser->current;
        while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
            if (check(parser, TOKEN_STRING)) {
                instance_count++;
                advance_parser(parser);
                if (check(parser, TOKEN_COLON)) {
                    advance_parser(parser);
                    if (check(parser, TOKEN_LBRACE)) {
                        int brace_count = 1;
                        advance_parser(parser);
                        while (brace_count > 0 && !is_at_end_parser(parser)) {
                            if (check(parser, TOKEN_LBRACE)) brace_count++;
                            if (check(parser, TOKEN_RBRACE)) brace_count--;
                            advance_parser(parser);
                        }
                    }
                }
            } else {
                advance_parser(parser);
            }
            if (check(parser, TOKEN_COMMA)) advance_parser(parser);
        }
        parser->current = saved_pos;
        
        data.count = instance_count;
        data.instances = (LinkedListDataInstance*)calloc(instance_count, sizeof(LinkedListDataInstance));
        
        // Parse instances
        int inst_idx = 0;
        while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
            if (check(parser, TOKEN_STRING)) {
                advance_parser(parser); // Skip string key
                if (check(parser, TOKEN_COLON)) advance_parser(parser);
                if (check(parser, TOKEN_LBRACE)) {
                    advance_parser(parser);
                    
                    // Count fields in this instance
                    int field_count = 0;
                    int saved_pos2 = parser->current;
                    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                        if (check(parser, TOKEN_IDENTIFIER)) {
                            field_count++;
                            advance_parser(parser);
                            if (check(parser, TOKEN_COLON)) {
                                advance_parser(parser);
                                advance_parser(parser); // value
                            }
                        } else {
                            advance_parser(parser);
                        }
                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                    }
                    parser->current = saved_pos2;
                    
                    data.instances[inst_idx].count = field_count;
                    data.instances[inst_idx].keys = (char**)malloc(sizeof(char*) * field_count);
                    data.instances[inst_idx].values = (LinkedListValue*)malloc(sizeof(LinkedListValue) * field_count);
                    
                    // Parse fields
                    int field_idx = 0;
                    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                        if (check(parser, TOKEN_IDENTIFIER)) {
                            Token* key = advance_parser(parser);
                            data.instances[inst_idx].keys[field_idx] = strdup(key->lexeme);
                            
                            if (check(parser, TOKEN_COLON)) advance_parser(parser);
                            
                            Token* value = peek_parser(parser);
                            if (value->type == TOKEN_NUMBER) {
                                advance_parser(parser);
                                data.instances[inst_idx].values[field_idx].type = SDC_LL_VALUE_INT;
                                data.instances[inst_idx].values[field_idx].data.int_value = value->value.number;
                            } else if (value->type == TOKEN_FLOAT) {
                                advance_parser(parser);
                                data.instances[inst_idx].values[field_idx].type = SDC_LL_VALUE_FLOAT;
                                data.instances[inst_idx].values[field_idx].data.float_value = value->value.float_number;
                            } else if (value->type == TOKEN_STRING) {
                                advance_parser(parser);
                                data.instances[inst_idx].values[field_idx].type = SDC_LL_VALUE_STRING;
                                data.instances[inst_idx].values[field_idx].data.string_value = strdup(value->value.string);
                            } else if (value->type == TOKEN_TRUE || value->type == TOKEN_FALSE) {
                                advance_parser(parser);
                                data.instances[inst_idx].values[field_idx].type = SDC_LL_VALUE_BOOL;
                                data.instances[inst_idx].values[field_idx].data.bool_value = value->value.bool_value;
                            }
                            
                            field_idx++;
                        } else {
                            advance_parser(parser);
                        }
                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                    }
                    
                    if (check(parser, TOKEN_RBRACE)) advance_parser(parser);
                    inst_idx++;
                }
            } else {
                advance_parser(parser);
            }
            if (check(parser, TOKEN_COMMA)) advance_parser(parser);
        }
        
        if (check(parser, TOKEN_RBRACKET)) advance_parser(parser);
    } else if (check(parser, TOKEN_LBRACE)) {
        // Single instance
        advance_parser(parser);
        data.is_array = false;
        data.count = 1;
        data.instances = (LinkedListDataInstance*)calloc(1, sizeof(LinkedListDataInstance));
        
        // Count fields
        int field_count = 0;
        int saved_pos = parser->current;
        while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
            if (check(parser, TOKEN_IDENTIFIER)) {
                field_count++;
                advance_parser(parser);
                if (check(parser, TOKEN_COLON)) {
                    advance_parser(parser);
                    advance_parser(parser); // value
                }
            } else {
                advance_parser(parser);
            }
            if (check(parser, TOKEN_COMMA)) advance_parser(parser);
        }
        parser->current = saved_pos;
        
        data.instances[0].count = field_count;
        data.instances[0].keys = (char**)malloc(sizeof(char*) * field_count);
        data.instances[0].values = (LinkedListValue*)malloc(sizeof(LinkedListValue) * field_count);
        
        // Parse fields
        int field_idx = 0;
        while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
            if (check(parser, TOKEN_IDENTIFIER)) {
                Token* key = advance_parser(parser);
                data.instances[0].keys[field_idx] = strdup(key->lexeme);
                
                if (check(parser, TOKEN_COLON)) advance_parser(parser);
                
                Token* value = peek_parser(parser);
                if (value->type == TOKEN_NUMBER) {
                    advance_parser(parser);
                    data.instances[0].values[field_idx].type = SDC_LL_VALUE_INT;
                    data.instances[0].values[field_idx].data.int_value = value->value.number;
                } else if (value->type == TOKEN_FLOAT) {
                    advance_parser(parser);
                    data.instances[0].values[field_idx].type = SDC_LL_VALUE_FLOAT;
                    data.instances[0].values[field_idx].data.float_value = value->value.float_number;
                } else if (value->type == TOKEN_STRING) {
                    advance_parser(parser);
                    data.instances[0].values[field_idx].type = SDC_LL_VALUE_STRING;
                    data.instances[0].values[field_idx].data.string_value = strdup(value->value.string);
                } else if (value->type == TOKEN_TRUE || value->type == TOKEN_FALSE) {
                    advance_parser(parser);
                    data.instances[0].values[field_idx].type = SDC_LL_VALUE_BOOL;
                    data.instances[0].values[field_idx].data.bool_value = value->value.bool_value;
                }
                
                field_idx++;
            } else {
                advance_parser(parser);
            }
            if (check(parser, TOKEN_COMMA)) advance_parser(parser);
        }
        
        if (check(parser, TOKEN_RBRACE)) advance_parser(parser);
    }
    
    return data;
}

static bool parse_characters(Parser* parser) {
    if (!expect(parser, TOKEN_CHARACTERS, "Expected 'characters'")) return false;
    if (!expect(parser, TOKEN_LBRACKET, "Expected '[' after 'characters'")) return false;
    
    // Count characters
    int count = 0;
    int saved_pos = parser->current;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            count++;
            advance_parser(parser);
            if (check(parser, TOKEN_COLON)) {
                advance_parser(parser);
            }
            if (check(parser, TOKEN_LBRACE)) {
                int brace_count = 1;
                advance_parser(parser);
                while (brace_count > 0 && !is_at_end_parser(parser)) {
                    if (check(parser, TOKEN_LBRACE)) brace_count++;
                    if (check(parser, TOKEN_RBRACE)) brace_count--;
                    advance_parser(parser);
                }
            }
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    parser->current = saved_pos;
    
    parser->story->characters = (Character*)calloc(count, sizeof(Character));
    parser->story->character_count = count;
    
    // Parse characters
    int char_index = 0;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            Token* name_token = advance_parser(parser);
            Character* character = &parser->story->characters[char_index++];
            character->name = strdup(name_token->value.string);
            character->biography = strdup("");
            character->description = strdup("");
            character->linked_list_names = NULL;
            character->linked_list_data = NULL;
            character->linked_list_count = 0;
            
            if (!expect(parser, TOKEN_COLON, "Expected ':' after character name")) return false;
            if (!expect(parser, TOKEN_LBRACE, "Expected '{' after ':'")) return false;
            
            while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                if (match(parser, TOKEN_BIOGRAPHY)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'biography'")) return false;
                    Token* bio = advance_parser(parser);
                    free(character->biography);
                    character->biography = strdup(bio->value.string);
                } else if (match(parser, TOKEN_DESCRIPTION)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'description'")) return false;
                    Token* desc = advance_parser(parser);
                    free(character->description);
                    character->description = strdup(desc->value.string);
                } else if (match(parser, TOKEN_LINKED_LIST_DATA)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'linked-list-data'")) return false;
                    if (!expect(parser, TOKEN_LBRACE, "Expected '{' after 'linked-list-data:'")) return false;
                    
                    // Count linked lists
                    int ll_count = 0;
                    int saved_pos2 = parser->current;
                    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                        if (check(parser, TOKEN_IDENTIFIER)) {
                            ll_count++;
                            advance_parser(parser);
                            if (check(parser, TOKEN_COLON)) {
                                advance_parser(parser);
                                // Skip the value part
                                int depth = 0;
                                if (check(parser, TOKEN_LBRACE)) {
                                    depth = 1;
                                    advance_parser(parser);
                                    while (depth > 0 && !is_at_end_parser(parser)) {
                                        if (check(parser, TOKEN_LBRACE)) depth++;
                                        if (check(parser, TOKEN_RBRACE)) depth--;
                                        advance_parser(parser);
                                    }
                                } else if (check(parser, TOKEN_LBRACKET)) {
                                    depth = 1;
                                    advance_parser(parser);
                                    while (depth > 0 && !is_at_end_parser(parser)) {
                                        if (check(parser, TOKEN_LBRACKET)) depth++;
                                        if (check(parser, TOKEN_RBRACKET)) depth--;
                                        if (check(parser, TOKEN_LBRACE)) depth++;
                                        if (check(parser, TOKEN_RBRACE)) depth--;
                                        advance_parser(parser);
                                    }
                                }
                            }
                        } else {
                            advance_parser(parser);
                        }
                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                    }
                    parser->current = saved_pos2;
                    
                    character->linked_list_count = ll_count;
                    character->linked_list_names = (char**)malloc(sizeof(char*) * ll_count);
                    character->linked_list_data = (LinkedListData*)malloc(sizeof(LinkedListData) * ll_count);
                    
                    // Parse linked lists
                    int ll_index = 0;
                    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                        if (check(parser, TOKEN_IDENTIFIER)) {
                            Token* list_name = advance_parser(parser);
                            character->linked_list_names[ll_index] = strdup(list_name->lexeme);
                            
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after list name")) return false;
                            
                            character->linked_list_data[ll_index] = parse_linked_list_data_value(parser);
                            ll_index++;
                        } else {
                            advance_parser(parser);
                        }
                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                    }
                    
                    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after linked-list-data")) return false;
                } else {
                    advance_parser(parser);
                }
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            
            if (!expect(parser, TOKEN_RBRACE, "Expected '}' after character")) return false;
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after characters")) return false;
    return true;
}

// Parse states section
static bool parse_states(Parser* parser) {
    if (!expect(parser, TOKEN_STATES, "Expected 'states'")) return false;
    if (!expect(parser, TOKEN_LBRACKET, "Expected '[' after 'states'")) return false;
    
    // Count states first
    int count = 0;
    int saved_pos = parser->current;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            count++;
            advance_parser(parser);
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    parser->current = saved_pos;
    
    // Allocate state array
    parser->story->states = (State*)calloc(count, sizeof(State));
    parser->story->state_count = count;
    
    // Parse states
    int state_index = 0;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            Token* state_token = advance_parser(parser);
            parser->story->states[state_index++].name = strdup(state_token->value.string);
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after states")) return false;
    return true;
}

// Parse global_vars section
static bool parse_global_vars(Parser* parser) {
    if (!expect(parser, TOKEN_GLOBAL_VARS, "Expected 'global_vars'")) return false;
    if (!expect(parser, TOKEN_LBRACKET, "Expected '[' after 'global_vars'")) return false;
    
    // Count variables first
    int count = 0;
    int saved_pos = parser->current;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            count++;
            advance_parser(parser);
            if (check(parser, TOKEN_COLON)) {
                advance_parser(parser);
            }
            if (check(parser, TOKEN_LBRACE)) {
                int brace_count = 1;
                advance_parser(parser);
                while (brace_count > 0 && !is_at_end_parser(parser)) {
                    if (check(parser, TOKEN_LBRACE)) brace_count++;
                    if (check(parser, TOKEN_RBRACE)) brace_count--;
                    advance_parser(parser);
                }
            }
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    parser->current = saved_pos;
    
    // Allocate variable array
    parser->story->global_vars = (GlobalVariable*)calloc(count, sizeof(GlobalVariable));
    parser->story->global_var_count = count;
    
    // Parse variables
    int var_index = 0;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            Token* name_token = advance_parser(parser);
            GlobalVariable* var = &parser->story->global_vars[var_index++];
            var->name = strdup(name_token->value.string);
            
            if (!expect(parser, TOKEN_COLON, "Expected ':' after variable name")) return false;
            if (!expect(parser, TOKEN_LBRACE, "Expected '{' after ':'")) return false;
            
            // Parse variable properties
            while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                if (match(parser, TOKEN_TYPE)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'type'")) return false;
                    Token* type_token = advance_parser(parser);
                    
                    if (strcmp(type_token->value.string, "string") == 0) {
                        var->type = SDC_VAR_TYPE_STRING;
                    } else if (strcmp(type_token->value.string, "int") == 0) {
                        var->type = SDC_VAR_TYPE_INT;
                    } else if (strcmp(type_token->value.string, "bool") == 0) {
                        var->type = SDC_VAR_TYPE_BOOL;
                    } else if (strcmp(type_token->value.string, "float") == 0) {
                        var->type = SDC_VAR_TYPE_FLOAT;
                    }
                } else if (match(parser, TOKEN_DEFAULT)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'default'")) return false;
                    
                    Token* default_token = peek_parser(parser);
                    
                    if (default_token->type == TOKEN_STRING) {
                        advance_parser(parser);
                        var->default_value.string_value = strdup(default_token->value.string);
                    } else if (default_token->type == TOKEN_NUMBER) {
                        advance_parser(parser);
                        var->default_value.int_value = default_token->value.number;
                    } else if (default_token->type == TOKEN_FLOAT) {
                        advance_parser(parser);
                        var->default_value.float_value = default_token->value.float_number;
                    } else if (default_token->type == TOKEN_TRUE || default_token->type == TOKEN_FALSE) {
                        advance_parser(parser);
                        var->default_value.bool_value = default_token->value.bool_value;
                    } else {
                        set_error(parser, "Expected default value");
                        return false;
                    }
                } else {
                    advance_parser(parser);
                }
                
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            
            if (!expect(parser, TOKEN_RBRACE, "Expected '}' after variable definition")) return false;
        } else {
            advance_parser(parser);
        }
        
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after global_vars")) return false;
    return true;
}

// Parse tags section
static bool parse_tags(Parser* parser) {
    if (!expect(parser, TOKEN_TAGS, "Expected 'tags'")) return false;
    if (!expect(parser, TOKEN_LBRACKET, "Expected '[' after 'tags'")) return false;
    
    // Count tags first
    int count = 0;
    int saved_pos = parser->current;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            count++;
            advance_parser(parser);
            if (check(parser, TOKEN_COLON)) {
                advance_parser(parser);
            }
            if (check(parser, TOKEN_LBRACE)) {
                int brace_count = 1;
                advance_parser(parser);
                while (brace_count > 0 && !is_at_end_parser(parser)) {
                    if (check(parser, TOKEN_LBRACE)) brace_count++;
                    if (check(parser, TOKEN_RBRACE)) brace_count--;
                    advance_parser(parser);
                }
            }
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    parser->current = saved_pos;
    
    // Allocate tag array
    parser->story->tags = (TagDefinition*)calloc(count, sizeof(TagDefinition));
    parser->story->tag_count = count;
    
    // Parse tags
    int tag_index = 0;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            if (!parse_tag_definition(parser, &parser->story->tags[tag_index++])) {
                return false;
            }
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after tags")) return false;
    return true;
}

static bool parse_tag_definition(Parser* parser, TagDefinition* tag) {
    // Tag name
    Token* name_token = advance_parser(parser);
    tag->name = strdup(name_token->value.string);
    
    if (!expect(parser, TOKEN_COLON, "Expected ':' after tag name")) return false;
    if (!expect(parser, TOKEN_LBRACE, "Expected '{' after ':'")) return false;
    
    tag->type = SDC_TAG_TYPE_SINGLE;
    tag->color = NULL;
    tag->keys = NULL;
    tag->key_count = 0;
    
    // Parse tag properties
    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
        if (match(parser, TOKEN_TYPE)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'type'")) return false;
            Token* type_token = advance_parser(parser);
            if (strcmp(type_token->value.string, "key-value") == 0) {
                tag->type = SDC_TAG_TYPE_KEYVALUE;
            } else if (strcmp(type_token->value.string, "single") == 0) {
                tag->type = SDC_TAG_TYPE_SINGLE;
            }
        } else if (match(parser, TOKEN_COLOR)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'color'")) return false;
            Token* color_token = advance_parser(parser);
            tag->color = strdup(color_token->value.string);
        } else if (match(parser, TOKEN_KEYS)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'keys'")) return false;
            if (!expect(parser, TOKEN_LBRACKET, "Expected '[' after 'keys:'")) return false;
            
            // Count keys
            int key_count = 0;
            int saved_pos = parser->current;
            while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
                if (check(parser, TOKEN_STRING)) key_count++;
                advance_parser(parser);
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            parser->current = saved_pos;
            
            // Allocate and parse keys
            tag->keys = (char**)malloc(sizeof(char*) * key_count);
            tag->key_count = key_count;
            
            int key_index = 0;
            while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
                if (check(parser, TOKEN_STRING)) {
                    Token* key_token = advance_parser(parser);
                    tag->keys[key_index++] = strdup(key_token->value.string);
                }
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            
            if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after keys")) return false;
        } else {
            advance_parser(parser);
        }
        
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after tag definition")) return false;
    return true;
}

static bool parse_chapter(Parser* parser, Chapter* chapter) {
    if (!expect(parser, TOKEN_CHAPTER, "Expected 'chapter'")) return false;
    
    Token* id_token = advance_parser(parser);
    if (id_token->type != TOKEN_NUMBER) {
        set_error(parser, "Expected chapter number");
        return false;
    }
    chapter->id = (int)id_token->value.number;
    
    if (!expect(parser, TOKEN_LBRACE, "Expected '{' after chapter number")) return false;
    
    chapter->name = NULL;
    
    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
        if (match(parser, TOKEN_NAME)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'name'")) return false;
            Token* name_token = advance_parser(parser);
            chapter->name = strdup(name_token->value.string);
        } else {
            advance_parser(parser);
        }
    }
    
    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after chapter")) return false;
    return true;
}

static bool parse_group_tags(Parser* parser, Group* group) {
    if (!expect(parser, TOKEN_LBRACKET, "Expected '[' for tags")) return false;
    
    // Count tags
    int tag_count = 0;
    int saved_pos = parser->current;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            tag_count++;
            advance_parser(parser);
            if (check(parser, TOKEN_COLON)) {
                advance_parser(parser);
                if (check(parser, TOKEN_LBRACE)) {
                    int brace_count = 1;
                    advance_parser(parser);
                    while (brace_count > 0 && !is_at_end_parser(parser)) {
                        if (check(parser, TOKEN_LBRACE)) brace_count++;
                        if (check(parser, TOKEN_RBRACE)) brace_count--;
                        advance_parser(parser);
                    }
                }
            }
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    parser->current = saved_pos;
    
    group->tags = (GroupTag*)calloc(tag_count, sizeof(GroupTag));
    group->tag_count = tag_count;
    
    // Parse tags
    int tag_index = 0;
    while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STRING)) {
            Token* tag_name = advance_parser(parser);
            group->tags[tag_index].tag_name = strdup(tag_name->value.string);
            group->tags[tag_index].selected_key = NULL;
            group->tags[tag_index].value = NULL;
            
            if (match(parser, TOKEN_COLON)) {
                if (check(parser, TOKEN_LBRACE)) {
                    advance_parser(parser);
                    
                    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                        if (check(parser, TOKEN_STRING)) {
                            Token* key = advance_parser(parser);
                            group->tags[tag_index].selected_key = strdup(key->value.string);
                            
                            if (match(parser, TOKEN_COLON)) {
                                Token* value = advance_parser(parser);
                                group->tags[tag_index].value = strdup(value->value.string);
                            }
                        } else {
                            advance_parser(parser);
                        }
                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                    }
                    
                    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after tag object")) return false;
                }
            }
            
            tag_index++;
        } else {
            advance_parser(parser);
        }
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after tags")) return false;
    return true;
}

static bool parse_node_graph(Parser* parser, NodeGraph* graph) {
    if (!expect(parser, TOKEN_LBRACE, "Expected '{' for nodes")) return false;
    
    graph->start_node = 0;
    graph->end_node = 0;
    graph->point_keys = NULL;
    graph->point_values = NULL;
    graph->point_value_counts = NULL;
    graph->point_count = 0;
    
    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
        if (match(parser, TOKEN_START)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'start'")) return false;
            Token* num = advance_parser(parser);
            graph->start_node = (int)num->value.number;
        } else if (match(parser, TOKEN_END)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'end'")) return false;
            Token* num = advance_parser(parser);
            graph->end_node = (int)num->value.number;
        } else if (match(parser, TOKEN_POINTS)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'points'")) return false;
            if (!expect(parser, TOKEN_LBRACE, "Expected '{' after 'points:'")) return false;
            
            // Count points
            int point_count = 0;
            int saved_pos = parser->current;
            while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                if (check(parser, TOKEN_NUMBER)) {
                    point_count++;
                    advance_parser(parser);
                    if (check(parser, TOKEN_COLON)) {
                        advance_parser(parser);
                        if (check(parser, TOKEN_LBRACKET)) {
                            int bracket_count = 1;
                            advance_parser(parser);
                            while (bracket_count > 0 && !is_at_end_parser(parser)) {
                                if (check(parser, TOKEN_LBRACKET)) bracket_count++;
                                if (check(parser, TOKEN_RBRACKET)) bracket_count--;
                                advance_parser(parser);
                            }
                        }
                    }
                } else {
                    advance_parser(parser);
                }
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            parser->current = saved_pos;
            
            graph->point_keys = (int*)malloc(sizeof(int) * point_count);
            graph->point_values = (int**)malloc(sizeof(int*) * point_count);
            graph->point_value_counts = (int*)malloc(sizeof(int) * point_count);
            graph->point_count = point_count;
            
            int point_index = 0;
            while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                if (check(parser, TOKEN_NUMBER)) {
                    Token* key = advance_parser(parser);
                    graph->point_keys[point_index] = (int)key->value.number;
                    
                    if (expect(parser, TOKEN_COLON, "Expected ':' after point key")) {
                        if (expect(parser, TOKEN_LBRACKET, "Expected '[' for point values")) {
                            // Count values
                            int value_count = 0;
                            int saved_pos2 = parser->current;
                            while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
                                if (check(parser, TOKEN_NUMBER)) value_count++;
                                advance_parser(parser);
                                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                            }
                            parser->current = saved_pos2;
                            
                            graph->point_values[point_index] = (int*)malloc(sizeof(int) * value_count);
                            graph->point_value_counts[point_index] = value_count;
                            
                            int value_index = 0;
                            while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
                                if (check(parser, TOKEN_NUMBER)) {
                                    Token* val = advance_parser(parser);
                                    graph->point_values[point_index][value_index++] = (int)val->value.number;
                                }
                                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                            }
                            
                            expect(parser, TOKEN_RBRACKET, "Expected ']' after point values");
                        }
                    }
                    point_index++;
                } else {
                    advance_parser(parser);
                }
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            
            if (!expect(parser, TOKEN_RBRACE, "Expected '}' after points")) return false;
        } else {
            advance_parser(parser);
        }
        
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after nodes")) return false;
    return true;
}

static bool parse_group(Parser* parser, Group* group) {
    if (!expect(parser, TOKEN_GROUP, "Expected 'group'")) return false;
    
    Token* id_token = advance_parser(parser);
    group->id = (int)id_token->value.number;
    
    if (!expect(parser, TOKEN_LBRACE, "Expected '{' after group number")) return false;
    
    group->chapter_id = 0;
    group->name = NULL;
    group->content = NULL;
    group->tags = NULL;
    group->tag_count = 0;
    group->linked_lists = NULL;
    group->linked_list_count = 0;
    group->parent_group = -1;  // -1 means no parent
    memset(&group->nodes, 0, sizeof(NodeGraph));
    
    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
        if (match(parser, TOKEN_CHAPTER)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'chapter'")) return false;
            Token* chapter_token = advance_parser(parser);
            group->chapter_id = (int)chapter_token->value.number;
        } else if (match(parser, TOKEN_NAME)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'name'")) return false;
            Token* name_token = advance_parser(parser);
            group->name = strdup(name_token->value.string);
        } else if (match(parser, TOKEN_CONTENT)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'content'")) return false;
            Token* content_token = advance_parser(parser);
            group->content = strdup(content_token->value.string);
        } else if (match(parser, TOKEN_PARENT_GROUP)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'parentGroup'")) return false;
            Token* parent_token = advance_parser(parser);
            group->parent_group = (int)parent_token->value.number;
        } else if (match(parser, TOKEN_TAGS)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'tags'")) return false;
            if (!parse_group_tags(parser, group)) return false;
        } else if (match(parser, TOKEN_NODES)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'nodes'")) return false;
            if (!parse_node_graph(parser, &group->nodes)) return false;
        } else if (match(parser, TOKEN_LINKED_LISTS)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'linked-lists'")) return false;
            if (!expect(parser, TOKEN_LBRACKET, "Expected '['")) return false;
            
            // Count linked lists
            int count = 0;
            int saved_pos = parser->current;
            while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
                if (check(parser, TOKEN_STRING)) count++;
                advance_parser(parser);
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            parser->current = saved_pos;
            
            group->linked_list_count = count;
            group->linked_lists = (char**)malloc(sizeof(char*) * count);
            
            // Parse linked lists
            int index = 0;
            while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
                if (check(parser, TOKEN_STRING)) {
                    Token* list_name = advance_parser(parser);
                    group->linked_lists[index++] = strdup(list_name->value.string);
                }
                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
            }
            
            if (!expect(parser, TOKEN_RBRACKET, "Expected ']'")) return false;
        } else {
            advance_parser(parser);
        }
        
        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
    }
    
    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after group")) return false;
    return true;
}

static bool parse_timeline(Parser* parser, Node* node) {
    if (!expect(parser, TOKEN_LBRACE, "Expected '{' for timeline")) return false;
    
    int item_count = 0;
    int saved_pos = parser->current;
    int brace_depth = 1;
    
    while (brace_depth > 0 && !is_at_end_parser(parser)) {
        if (check(parser, TOKEN_DIALOGUE)) {
            item_count++;
            advance_parser(parser);
            advance_parser(parser);
            if (check(parser, TOKEN_LBRACE)) {
                brace_depth++;
                advance_parser(parser);
                while (brace_depth > 1 && !is_at_end_parser(parser)) {
                    if (check(parser, TOKEN_LBRACE)) brace_depth++;
                    if (check(parser, TOKEN_RBRACE)) brace_depth--;
                    advance_parser(parser);
                }
            }
        } else if (check(parser, TOKEN_ACTION)) {
            item_count++;
            advance_parser(parser);
            advance_parser(parser);
            if (check(parser, TOKEN_LBRACE)) {
                brace_depth++;
                advance_parser(parser);
                while (brace_depth > 1 && !is_at_end_parser(parser)) {
                    if (check(parser, TOKEN_LBRACE)) brace_depth++;
                    if (check(parser, TOKEN_RBRACE)) brace_depth--;
                    advance_parser(parser);
                }
            }
        } else {
            if (check(parser, TOKEN_LBRACE)) brace_depth++;
            if (check(parser, TOKEN_RBRACE)) brace_depth--;
            advance_parser(parser);
        }
    }
    
    parser->current = saved_pos;
    
    node->timeline = (TimelineItem*)calloc(item_count, sizeof(TimelineItem));
    node->timeline_count = item_count;
    
    int item_index = 0;
    
    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser) && item_index < item_count) {
        if (match(parser, TOKEN_DIALOGUE)) {
            Token* num = advance_parser(parser);
            if (!expect(parser, TOKEN_LBRACE, "Expected '{' after dialogue")) return false;
            
            node->timeline[item_index].type = SDC_TIMELINE_ITEM_DIALOGUE;
            node->timeline[item_index].number = (int)num->value.number;
            
            int line_count = 0;
            int saved_pos2 = parser->current;
            while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                if (check(parser, TOKEN_IDENTIFIER)) {
                    line_count++;
                    advance_parser(parser);
                    if (check(parser, TOKEN_COLON)) {
                        advance_parser(parser);
                        if (check(parser, TOKEN_STRING)) {
                            advance_parser(parser);
                        }
                    }
                } else {
                    advance_parser(parser);
                }
            }
            parser->current = saved_pos2;
            
            node->timeline[item_index].data.dialogue.characters = 
                (char**)malloc(sizeof(char*) * line_count);
            node->timeline[item_index].data.dialogue.texts = 
                (char**)malloc(sizeof(char*) * line_count);
            node->timeline[item_index].data.dialogue.line_count = line_count;
            
            int line_index = 0;
            while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser) && line_index < line_count) {
                Token* character = peek_parser(parser);
                if (character->type == TOKEN_IDENTIFIER) {
                    node->timeline[item_index].data.dialogue.characters[line_index] = 
                        strdup(character->lexeme);
                    advance_parser(parser);
                } else {
                    advance_parser(parser);
                    continue;
                }
                
                if (!expect(parser, TOKEN_COLON, "Expected ':' after character")) return false;
                
                Token* text = peek_parser(parser);
                if (text->type == TOKEN_STRING) {
                    node->timeline[item_index].data.dialogue.texts[line_index] = 
                        strdup(text->value.string);
                    advance_parser(parser);
                } else {
                    set_error(parser, "Expected dialogue text");
                    return false;
                }
                
                line_index++;
            }
            
            if (!expect(parser, TOKEN_RBRACE, "Expected '}' after dialogue")) return false;
            item_index++;
            
        } else if (match(parser, TOKEN_ACTION)) {
            Token* num = advance_parser(parser);
            if (!expect(parser, TOKEN_LBRACE, "Expected '{' after action")) return false;
            
            node->timeline[item_index].type = SDC_TIMELINE_ITEM_ACTION;
            node->timeline[item_index].number = (int)num->value.number;
            node->timeline[item_index].data.action.type = SDC_ACTION_TYPE_CODE;
            
            int action_brace_depth = 1;
            while (action_brace_depth > 0 && !is_at_end_parser(parser)) {
                if (match(parser, TOKEN_TYPE)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'type'")) return false;
                    Token* type_token = peek_parser(parser);
                    
                    if (type_token->type == TOKEN_STRING) {
                        advance_parser(parser);
                        
                        if (strcmp(type_token->value.string, "code") == 0) {
                            node->timeline[item_index].data.action.type = SDC_ACTION_TYPE_CODE;
                            
                            while (action_brace_depth > 0 && !is_at_end_parser(parser)) {
                                if (check(parser, TOKEN_CODE_BLOCK)) {
                                    Token* code_token = advance_parser(parser);
                                    node->timeline[item_index].data.action.data.code.code = 
                                        strdup(code_token->value.string);
                                }
                                if (check(parser, TOKEN_LBRACE)) action_brace_depth++;
                                if (check(parser, TOKEN_RBRACE)) {
                                    action_brace_depth--;
                                    if (action_brace_depth == 0) break;
                                }
                                advance_parser(parser);
                            }
                            break;
                        } else if (strcmp(type_token->value.string, "event") == 0) {
                            node->timeline[item_index].data.action.type = SDC_ACTION_TYPE_EVENT;
                            node->timeline[item_index].data.action.data.event.event_type = SDC_EVENT_TYPE_UNKNOWN;
                        } else if (strcmp(type_token->value.string, "choice") == 0) {
                            node->timeline[item_index].data.action.type = SDC_ACTION_TYPE_CHOICE;
                        }
                    } else {
                        advance_parser(parser);
                    }
                } else if (match(parser, TOKEN_DATA)) {
                    // Parse data object for events
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'data'")) return false;
                    if (!expect(parser, TOKEN_LBRACE, "Expected '{' after 'data:'")) return false;
                    
                    EventActionData* event = &node->timeline[item_index].data.action.data.event;
                    event->event_type = SDC_EVENT_TYPE_UNKNOWN;
                    
                    int data_brace_depth = 1;
                    while (data_brace_depth > 0 && !is_at_end_parser(parser)) {
                        if (match(parser, TOKEN_TYPE)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'type'")) return false;
                            Token* event_type = advance_parser(parser);
                            
                            if (event_type->type == TOKEN_STRING) {
                                if (strcmp(event_type->value.string, "next-node") == 0) {
                                    event->event_type = SDC_EVENT_TYPE_NEXT_NODE;
                                } else if (strcmp(event_type->value.string, "exit-current-node") == 0) {
                                    event->event_type = SDC_EVENT_TYPE_EXIT_CURRENT_NODE;
                                } else if (strcmp(event_type->value.string, "exit-current-group") == 0) {
                                    event->event_type = SDC_EVENT_TYPE_EXIT_CURRENT_GROUP;
                                } else if (strcmp(event_type->value.string, "adjust-variable") == 0) {
                                    event->event_type = SDC_EVENT_TYPE_ADJUST_VARIABLE;
                                    event->data.adjust_variable.name = NULL;
                                    event->data.adjust_variable.value = NULL;
                                    event->data.adjust_variable.increment = 0.0;
                                    event->data.adjust_variable.is_toggle = false;
                                    event->data.adjust_variable.has_increment = false;
                                    event->data.adjust_variable.has_value = false;
                                } else if (strcmp(event_type->value.string, "add-state") == 0) {
                                    event->event_type = SDC_EVENT_TYPE_ADD_STATE;
                                    event->data.add_state.name = NULL;
                                    event->data.add_state.character = NULL;
                                } else if (strcmp(event_type->value.string, "remove-state") == 0) {
                                    event->event_type = SDC_EVENT_TYPE_REMOVE_STATE;
                                    event->data.remove_state.name = NULL;
                                    event->data.remove_state.character = NULL;
                                } else if (strcmp(event_type->value.string, "progress-story") == 0) {
                                    event->event_type = SDC_EVENT_TYPE_PROGRESS_STORY;
                                    event->data.progress_story.chapter_id = -1;
                                    event->data.progress_story.group_id = -1;
                                    event->data.progress_story.node_id = -1;
                                } else if (strcmp(event_type->value.string, "linked-list") == 0) {
                                    event->event_type = SDC_EVENT_TYPE_LINKED_LIST;
                                    event->data.linked_list.reference = NULL;
                                    event->data.linked_list.modifications = NULL;
                                    event->data.linked_list.modification_count = 0;
                                    
                                    // Parse reference and values
                                    while (!check(parser, TOKEN_RBRACE) && data_brace_depth > 0) {
                                        if (match(parser, TOKEN_REFERENCE)) {
                                            if (!expect(parser, TOKEN_COLON, "Expected ':'")) return false;
                                            Token* ref = advance_parser(parser);
                                            event->data.linked_list.reference = strdup(ref->value.string);
                                        } else if (match(parser, TOKEN_VALUES)) {
                                            if (!expect(parser, TOKEN_COLON, "Expected ':'")) return false;
                                            if (!expect(parser, TOKEN_LBRACKET, "Expected '['")) return false;
                                            
                                            // Count modifications
                                            int mod_count = 0;
                                            int saved_pos3 = parser->current;
                                            while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
                                                if (check(parser, TOKEN_STRING)) {
                                                    mod_count++;
                                                    advance_parser(parser);
                                                    if (check(parser, TOKEN_COLON)) {
                                                        advance_parser(parser);
                                                        if (check(parser, TOKEN_LBRACE)) {
                                                            int depth = 1;
                                                            advance_parser(parser);
                                                            while (depth > 0 && !is_at_end_parser(parser)) {
                                                                if (check(parser, TOKEN_LBRACE)) depth++;
                                                                if (check(parser, TOKEN_RBRACE)) depth--;
                                                                advance_parser(parser);
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    advance_parser(parser);
                                                }
                                                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                                            }
                                            parser->current = saved_pos3;
                                            
                                            event->data.linked_list.modification_count = mod_count;
                                            event->data.linked_list.modifications = 
                                                (LinkedListFieldModification*)calloc(mod_count, sizeof(LinkedListFieldModification));
                                            
                                            // Parse modifications
                                            int mod_idx = 0;
                                            while (!check(parser, TOKEN_RBRACKET) && !is_at_end_parser(parser)) {
                                                if (check(parser, TOKEN_STRING)) {
                                                    Token* field_name = advance_parser(parser);
                                                    LinkedListFieldModification* mod = &event->data.linked_list.modifications[mod_idx++];
                                                    mod->field = strdup(field_name->value.string);
                                                    mod->has_amount = false;
                                                    mod->has_set = false;
                                                    mod->has_append = false;
                                                    mod->has_replace = false;
                                                    mod->is_toggle = false;
                                                    
                                                    if (!expect(parser, TOKEN_COLON, "Expected ':'")) return false;
                                                    if (!expect(parser, TOKEN_LBRACE, "Expected '{'")) return false;
                                                    
                                                    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
                                                        if (match(parser, TOKEN_AMOUNT)) {
                                                            if (!expect(parser, TOKEN_COLON, "Expected ':'")) return false;
                                                            Token* amt = advance_parser(parser);
                                                            if (amt->type == TOKEN_FLOAT) {
                                                                mod->amount = amt->value.float_number;
                                                            } else {
                                                                mod->amount = (double)amt->value.number;
                                                            }
                                                            mod->has_amount = true;
                                                        } else if (match(parser, TOKEN_SET)) {
                                                            if (!expect(parser, TOKEN_COLON, "Expected ':'")) return false;
                                                            Token* val = advance_parser(parser);
                                                            mod->set_value = strdup(val->value.string);
                                                            mod->has_set = true;
                                                        } else if (match(parser, TOKEN_APPEND)) {
                                                            if (!expect(parser, TOKEN_COLON, "Expected ':'")) return false;
                                                            Token* val = advance_parser(parser);
                                                            mod->append_value = strdup(val->value.string);
                                                            mod->has_append = true;
                                                        } else if (match(parser, TOKEN_REPLACE)) {
                                                            if (!expect(parser, TOKEN_COLON, "Expected ':'")) return false;
                                                            Token* val = advance_parser(parser);
                                                            mod->replace_value = strdup(val->value.string);
                                                            mod->has_replace = true;
                                                        } else if (match(parser, TOKEN_TOGGLE)) {
                                                            if (!expect(parser, TOKEN_COLON, "Expected ':'")) return false;
                                                            Token* val = advance_parser(parser);
                                                            mod->is_toggle = (strcmp(val->value.string, "toggle") == 0);
                                                        } else {
                                                            advance_parser(parser);
                                                        }
                                                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                                                    }
                                                    
                                                    if (!expect(parser, TOKEN_RBRACE, "Expected '}'")) return false;
                                                } else {
                                                    advance_parser(parser);
                                                }
                                                if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                                            }
                                            
                                            if (!expect(parser, TOKEN_RBRACKET, "Expected ']'")) return false;
                                        }
                                        
                                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                                    }
                                }
                            }
                        } else if (match(parser, TOKEN_NAME)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'name'")) return false;
                            Token* name = advance_parser(parser);
                            if (event->event_type == SDC_EVENT_TYPE_ADJUST_VARIABLE) {
                                event->data.adjust_variable.name = strdup(name->value.string);
                            } else if (event->event_type == SDC_EVENT_TYPE_ADD_STATE || 
                                      event->event_type == SDC_EVENT_TYPE_REMOVE_STATE) {
                                if (event->event_type == SDC_EVENT_TYPE_ADD_STATE) {
                                    event->data.add_state.name = strdup(name->value.string);
                                } else {
                                    event->data.remove_state.name = strdup(name->value.string);
                                }
                            }
                        } else if (match(parser, TOKEN_INCREMENT)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'increment'")) return false;
                            Token* inc = advance_parser(parser);
                            if (event->event_type == SDC_EVENT_TYPE_ADJUST_VARIABLE) {
                                if (inc->type == TOKEN_FLOAT) {
                                    event->data.adjust_variable.increment = inc->value.float_number;
                                } else if (inc->type == TOKEN_NUMBER) {
                                    event->data.adjust_variable.increment = (double)inc->value.number;
                                }
                                event->data.adjust_variable.has_increment = true;
                            }
                        } else if (match(parser, TOKEN_VALUE)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'value'")) return false;
                            Token* val = advance_parser(parser);
                            if (event->event_type == SDC_EVENT_TYPE_ADJUST_VARIABLE) {
                                event->data.adjust_variable.value = strdup(val->value.string);
                                event->data.adjust_variable.has_value = true;
                            }
                        } else if (match(parser, TOKEN_TOGGLE)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'toggle'")) return false;
                            Token* tog = advance_parser(parser);
                            if (event->event_type == SDC_EVENT_TYPE_ADJUST_VARIABLE) {
                                event->data.adjust_variable.is_toggle = 
                                    (strcmp(tog->value.string, "toggle") == 0);
                            }
                        } else if (match(parser, TOKEN_CHARACTER)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'character'")) return false;
                            Token* chr = advance_parser(parser);
                            if (event->event_type == SDC_EVENT_TYPE_ADD_STATE) {
                                event->data.add_state.character = strdup(chr->value.string);
                            } else if (event->event_type == SDC_EVENT_TYPE_REMOVE_STATE) {
                                event->data.remove_state.character = strdup(chr->value.string);
                            }
                        } else if (match(parser, TOKEN_CHAPTER)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'chapter'")) return false;
                            if (!expect(parser, TOKEN_AT, "Expected '@' for chapter reference")) return false;
                            Token* ref_type = advance_parser(parser);
                            if (!expect(parser, TOKEN_LPAREN, "Expected '(' after reference type")) return false;
                            Token* ref_id = advance_parser(parser);
                            if (!expect(parser, TOKEN_RPAREN, "Expected ')' after reference id")) return false;
                            
                            if (event->event_type == SDC_EVENT_TYPE_PROGRESS_STORY) {
                                event->data.progress_story.chapter_id = (int)ref_id->value.number;
                            }
                        } else if (match(parser, TOKEN_GROUP)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'group'")) return false;
                            if (!expect(parser, TOKEN_AT, "Expected '@' for group reference")) return false;
                            Token* ref_type = advance_parser(parser);
                            if (!expect(parser, TOKEN_LPAREN, "Expected '(' after reference type")) return false;
                            Token* ref_id = advance_parser(parser);
                            if (!expect(parser, TOKEN_RPAREN, "Expected ')' after reference id")) return false;
                            
                            if (event->event_type == SDC_EVENT_TYPE_PROGRESS_STORY) {
                                event->data.progress_story.group_id = (int)ref_id->value.number;
                            }
                        } else if (match(parser, TOKEN_NODE)) {
                            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'node'")) return false;
                            if (!expect(parser, TOKEN_AT, "Expected '@' for node reference")) return false;
                            Token* ref_type = advance_parser(parser);
                            if (!expect(parser, TOKEN_LPAREN, "Expected '(' after reference type")) return false;
                            Token* ref_id = advance_parser(parser);
                            if (!expect(parser, TOKEN_RPAREN, "Expected ')' after reference id")) return false;
                            
                            if (event->event_type == SDC_EVENT_TYPE_PROGRESS_STORY) {
                                event->data.progress_story.node_id = (int)ref_id->value.number;
                            }
                        
                        } else {
                            if (check(parser, TOKEN_LBRACE)) data_brace_depth++;
                            if (check(parser, TOKEN_RBRACE)) {
                                data_brace_depth--;
                                if (data_brace_depth == 0) break;
                            }
                            advance_parser(parser);
                        }
                        
                        if (check(parser, TOKEN_COMMA)) advance_parser(parser);
                    }
                    
                    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after data")) return false;
                } else if (match(parser, TOKEN_GOTO)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'goto'")) return false;
                    if (!expect(parser, TOKEN_AT, "Expected '@' for reference")) return false;
                    
                    Token* ref_type = advance_parser(parser);
                    if (!expect(parser, TOKEN_LPAREN, "Expected '(' after reference type")) return false;
                    Token* ref_id = advance_parser(parser);
                    if (!expect(parser, TOKEN_RPAREN, "Expected ')' after reference id")) return false;
                    
                    if (strcmp(ref_type->lexeme, "node") == 0) {
                        node->timeline[item_index].data.action.type = SDC_ACTION_TYPE_GOTO;
                        node->timeline[item_index].data.action.data.goto_action.target_node = 
                            (int)ref_id->value.number;
                    }
                } else if (match(parser, TOKEN_EXIT)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'exit'")) return false;
                    Token* target = advance_parser(parser);
                    node->timeline[item_index].data.action.type = SDC_ACTION_TYPE_EXIT;
                    node->timeline[item_index].data.action.data.exit_action.target = 
                        strdup(target->value.string);
                } else if (match(parser, TOKEN_ENTER)) {
                    if (!expect(parser, TOKEN_COLON, "Expected ':' after 'enter'")) return false;
                    if (!expect(parser, TOKEN_AT, "Expected '@' for reference")) return false;
                    
                    Token* ref_type = advance_parser(parser);
                    if (!expect(parser, TOKEN_LPAREN, "Expected '(' after reference type")) return false;
                    Token* ref_id = advance_parser(parser);
                    if (!expect(parser, TOKEN_RPAREN, "Expected ')' after reference id")) return false;
                    
                    if (strcmp(ref_type->lexeme, "group") == 0) {
                        node->timeline[item_index].data.action.type = SDC_ACTION_TYPE_ENTER;
                        node->timeline[item_index].data.action.data.enter_action.target_group = 
                            (int)ref_id->value.number;
                    }
                } else {
                    if (check(parser, TOKEN_LBRACE)) action_brace_depth++;
                    if (check(parser, TOKEN_RBRACE)) {
                        action_brace_depth--;
                        if (action_brace_depth == 0) break;
                    }
                    advance_parser(parser);
                }
            }
            
            if (!expect(parser, TOKEN_RBRACE, "Expected '}' after action")) return false;
            item_index++;
            
        } else {
            advance_parser(parser);
        }
    }
    
    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after timeline")) return false;
    return true;
}

static bool parse_node(Parser* parser, Node* node) {
    if (!expect(parser, TOKEN_NODE, "Expected 'node'")) return false;
    
    Token* id_token = advance_parser(parser);
    node->id = (int)id_token->value.number;
    
    if (!expect(parser, TOKEN_LBRACE, "Expected '{' after node number")) return false;
    
    node->title = NULL;
    node->content = NULL;
    node->timeline = NULL;
    node->timeline_count = 0;
    
    while (!check(parser, TOKEN_RBRACE) && !is_at_end_parser(parser)) {
        if (match(parser, TOKEN_TITLE)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'title'")) return false;
            Token* title_token = advance_parser(parser);
            node->title = strdup(title_token->value.string);
        } else if (match(parser, TOKEN_CONTENT)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'content'")) return false;
            Token* content_token = advance_parser(parser);
            node->content = strdup(content_token->value.string);
        } else if (match(parser, TOKEN_TIMELINE)) {
            if (!expect(parser, TOKEN_COLON, "Expected ':' after 'timeline'")) return false;
            if (!parse_timeline(parser, node)) return false;
        } else {
            advance_parser(parser);
        }
    }
    
    if (!expect(parser, TOKEN_RBRACE, "Expected '}' after node")) return false;
    return true;
}

static bool parse_story(Parser* parser) {
    while (!is_at_end_parser(parser)) {
        if (check(parser, TOKEN_STATES)) {
            if (!parse_states(parser)) return false;
        } else if (check(parser, TOKEN_GLOBAL_VARS)) {
            if (!parse_global_vars(parser)) return false;
        } else if (check(parser, TOKEN_TAGS)) {
            if (!parse_tags(parser)) return false;
        } else if (check(parser, TOKEN_CHAPTER)) {
            parser->story->chapter_count++;
            parser->story->chapters = (Chapter*)realloc(parser->story->chapters, 
                sizeof(Chapter) * parser->story->chapter_count);
            
            if (!parse_chapter(parser, &parser->story->chapters[parser->story->chapter_count - 1])) {
                return false;
            }
        } else if (check(parser, TOKEN_GROUP)) {
            parser->story->group_count++;
            parser->story->groups = (Group*)realloc(parser->story->groups,
                sizeof(Group) * parser->story->group_count);
            
            if (!parse_group(parser, &parser->story->groups[parser->story->group_count - 1])) {
                return false;
            }
        } else if (check(parser, TOKEN_NODE)) {
            parser->story->node_count++;
            parser->story->nodes = (Node*)realloc(parser->story->nodes,
                sizeof(Node) * parser->story->node_count);
            
            if (!parse_node(parser, &parser->story->nodes[parser->story->node_count - 1])) {
                return false;
            }
        else if (check(parser, TOKEN_LINKED_LISTS)) {
            if (!parse_linked_lists(parser)) return false;
        } else if (check(parser, TOKEN_CHARACTERS)) {
            if (!parse_characters(parser)) return false;
        }

        } else {
            advance_parser(parser);
        }
    }
    
    return true;
}

// ============================================================================
// PUBLIC API IMPLEMENTATION
// ============================================================================

StoryData* sdc_parse_string(const char* source) {
    if (!source) return NULL;
    
    Lexer* lexer = lexer_create(source);
    lexer_scan_tokens(lexer);
    
    for (int i = 0; i < lexer->token_count; i++) {
        if (lexer->tokens[i].type == TOKEN_ERROR) {
            if (last_error) free(last_error);
            last_error = strdup("Lexer error: invalid token");
            lexer_free(lexer);
            return NULL;
        }
    }
    
    Parser* parser = parser_create(lexer->tokens, lexer->token_count);
    
    if (!parse_story(parser)) {
        StoryData* failed_story = parser->story;
        sdc_free(failed_story);
        parser->story = NULL;
        parser_free(parser);
        lexer_free(lexer);
        return NULL;
    }
    
    StoryData* result = parser->story;
    parser->story = NULL;
    
    parser_free(parser);
    lexer_free(lexer);
    
    return result;
}

StoryData* sdc_parse_file(const char* filename) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        if (last_error) free(last_error);
        last_error = strdup("Failed to open file");
        return NULL;
    }
    
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    char* source = (char*)malloc(size + 1);
    fread(source, 1, size, file);
    source[size] = '\0';
    fclose(file);
    
    StoryData* result = sdc_parse_string(source);
    free(source);
    
    return result;
}

void sdc_free(StoryData* data) {
    if (!data) return;
    
    // Free states
    for (int i = 0; i < data->state_count; i++) {
        free(data->states[i].name);
    }
    free(data->states);
    
    // Free global variables
    for (int i = 0; i < data->global_var_count; i++) {
        free(data->global_vars[i].name);
        if (data->global_vars[i].type == SDC_VAR_TYPE_STRING) {
            free(data->global_vars[i].default_value.string_value);
        }
    }
    free(data->global_vars);
    
    // Free tags
    for (int i = 0; i < data->tag_count; i++) {
        free(data->tags[i].name);
        free(data->tags[i].color);
        for (int j = 0; j < data->tags[i].key_count; j++) {
            free(data->tags[i].keys[j]);
        }
        free(data->tags[i].keys);
    }
    free(data->tags);
    
    // Free chapters
    for (int i = 0; i < data->chapter_count; i++) {
        free(data->chapters[i].name);
    }
    free(data->chapters);
    
    // Free groups (updated to include linked_lists)
    for (int i = 0; i < data->group_count; i++) {
        free(data->groups[i].name);
        free(data->groups[i].content);
        
        for (int j = 0; j < data->groups[i].tag_count; j++) {
            free(data->groups[i].tags[j].tag_name);
            free(data->groups[i].tags[j].selected_key);
            free(data->groups[i].tags[j].value);
        }
        free(data->groups[i].tags);
        
        for (int j = 0; j < data->groups[i].linked_list_count; j++) {
            free(data->groups[i].linked_lists[j]);
        }
        free(data->groups[i].linked_lists);
        
        free(data->groups[i].nodes.point_keys);
        for (int j = 0; j < data->groups[i].nodes.point_count; j++) {
            free(data->groups[i].nodes.point_values[j]);
        }
        free(data->groups[i].nodes.point_values);
        free(data->groups[i].nodes.point_value_counts);
    }
    free(data->groups);
    
    // Free nodes (updated to include linked-list events)
    for (int i = 0; i < data->node_count; i++) {
        free(data->nodes[i].title);
        free(data->nodes[i].content);
        
        for (int j = 0; j < data->nodes[i].timeline_count; j++) {
            if (data->nodes[i].timeline[j].type == SDC_TIMELINE_ITEM_DIALOGUE) {
                Dialogue* d = &data->nodes[i].timeline[j].data.dialogue;
                for (int k = 0; k < d->line_count; k++) {
                    free(d->characters[k]);
                    free(d->texts[k]);
                }
                free(d->characters);
                free(d->texts);
            } else if (data->nodes[i].timeline[j].type == SDC_TIMELINE_ITEM_ACTION) {
                Action* a = &data->nodes[i].timeline[j].data.action;
                if (a->type == SDC_ACTION_TYPE_CODE) {
                    free(a->data.code.code);
                } else if (a->type == SDC_ACTION_TYPE_EXIT) {
                    free(a->data.exit_action.target);
                } else if (a->type == SDC_ACTION_TYPE_EVENT) {
                    EventActionData* e = &a->data.event;
                    if (e->event_type == SDC_EVENT_TYPE_ADJUST_VARIABLE) {
                        free(e->data.adjust_variable.name);
                        free(e->data.adjust_variable.value);
                    } else if (e->event_type == SDC_EVENT_TYPE_ADD_STATE) {
                        free(e->data.add_state.name);
                        free(e->data.add_state.character);
                    } else if (e->event_type == SDC_EVENT_TYPE_REMOVE_STATE) {
                        free(e->data.remove_state.name);
                        free(e->data.remove_state.character);
                    } else if (e->event_type == SDC_EVENT_TYPE_LINKED_LIST) {
                        free(e->data.linked_list.reference);
                        for (int k = 0; k < e->data.linked_list.modification_count; k++) {
                            free(e->data.linked_list.modifications[k].field);
                            free(e->data.linked_list.modifications[k].set_value);
                            free(e->data.linked_list.modifications[k].append_value);
                            free(e->data.linked_list.modifications[k].replace_value);
                        }
                        free(e->data.linked_list.modifications);
                    }
                }
            }
        }
        free(data->nodes[i].timeline);
    }
    free(data->nodes);
    
    for (int i = 0; i < data->linked_list_count; i++) {
        free(data->linked_lists[i].name);
        free(data->linked_lists[i].scope);
        for (int j = 0; j < data->linked_lists[i].field_count; j++) {
            free(data->linked_lists[i].field_names[j]);
            free(data->linked_lists[i].fields[j].type);
        }
        free(data->linked_lists[i].field_names);
        free(data->linked_lists[i].fields);
    }
    free(data->linked_lists);
    
    // Free characters
    for (int i = 0; i < data->character_count; i++) {
        free(data->characters[i].name);
        free(data->characters[i].biography);
        free(data->characters[i].description);
        
        for (int j = 0; j < data->characters[i].linked_list_count; j++) {
            free(data->characters[i].linked_list_names[j]);
            
            LinkedListData* ll_data = &data->characters[i].linked_list_data[j];
            for (int k = 0; k < ll_data->count; k++) {
                for (int m = 0; m < ll_data->instances[k].count; m++) {
                    free(ll_data->instances[k].keys[m]);
                    if (ll_data->instances[k].values[m].type == SDC_LL_VALUE_STRING) {
                        free(ll_data->instances[k].values[m].data.string_value);
                    }
                }
                free(ll_data->instances[k].keys);
                free(ll_data->instances[k].values);
            }
            free(ll_data->instances);
        }
        free(data->characters[i].linked_list_names);
        free(data->characters[i].linked_list_data);
    }
    free(data->characters);
    
    free(data);
}

const char* sdc_get_error(void) {
    return last_error;
}

LinkedListDefinition* sdc_get_linked_list(StoryData* data, const char* name) {
    for (int i = 0; i < data->linked_list_count; i++) {
        if (strcmp(data->linked_lists[i].name, name) == 0) {
            return &data->linked_lists[i];
        }
    }
    return NULL;
}

Character* sdc_get_character(StoryData* data, const char* name) {
    for (int i = 0; i < data->character_count; i++) {
        if (strcmp(data->characters[i].name, name) == 0) {
            return &data->characters[i];
        }
    }
    return NULL;
}

LinkedListDefinition* sdc_get_linked_lists(StoryData* data, int* count) {
    if (count) *count = data->linked_list_count;
    return data->linked_lists;
}

Character* sdc_get_characters(StoryData* data, int* count) {
    if (count) *count = data->character_count;
    return data->characters;
}

Chapter* sdc_get_chapter(StoryData* data, int id) {
    for (int i = 0; i < data->chapter_count; i++) {
        if (data->chapters[i].id == id) {
            return &data->chapters[i];
        }
    }
    return NULL;
}

Group* sdc_get_group(StoryData* data, int id) {
    for (int i = 0; i < data->group_count; i++) {
        if (data->groups[i].id == id) {
            return &data->groups[i];
        }
    }
    return NULL;
}

Node* sdc_get_node(StoryData* data, int id) {
    for (int i = 0; i < data->node_count; i++) {
        if (data->nodes[i].id == id) {
            return &data->nodes[i];
        }
    }
    return NULL;
}

TagDefinition* sdc_get_tag_definition(StoryData* data, const char* name) {
    for (int i = 0; i < data->tag_count; i++) {
        if (strcmp(data->tags[i].name, name) == 0) {
            return &data->tags[i];
        }
    }
    return NULL;
}

GlobalVariable* sdc_get_global_variable(StoryData* data, const char* name) {
    for (int i = 0; i < data->global_var_count; i++) {
        if (strcmp(data->global_vars[i].name, name) == 0) {
            return &data->global_vars[i];
        }
    }
    return NULL;
}

TagDefinition* sdc_get_tag_definitions(StoryData* data, int* count) {
    if (count) *count = data->tag_count;
    return data->tags;
}

GlobalVariable* sdc_get_global_variables(StoryData* data, int* count) {
    if (count) *count = data->global_var_count;
    return data->global_vars;
}

State* sdc_get_states(StoryData* data, int* count) {
    if (count) *count = data->state_count;
    return data->states;
}

bool sdc_validate_references(StoryData* data) {
    // TODO: Implement reference validation
    return true;
}